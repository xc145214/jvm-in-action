# HotSpot 的算法实现

## 枚举根节点

> 整个分析期间整个执行系统看起来就像被冻结在某个时间节点上，不可以出现分析过程中对象的引用链不断变法的情况，改点不满足的话分析的准确性就无法保证。

枚举根节点时需要逐个检查引用，此工作必须在一个能保证一致性的快照中进行。这点是导致 GC 进行时必须停顿所有的 Java执行线程 （STOP THE WORLD）的一个重要原因。
即使是号称几乎不发生停顿的 CMS收集器中，枚举根节点也是必须停顿的。

目前的主流 Java 虚拟机使用的都是准确式 GC 。所以系统停顿后不需要一个不漏的检查所有执行上下文和全局的引用位置，虚拟机有办法直接知道哪些地方存放着对象的引用。
在 HotSpot 中使用一组称为 OopMap 的数据结构来达到这个目的。

## 安全点 Safepoint

在 OopMap 的协助下，HotSpot 可以快速并且准确的完成 GC Roots 枚举，但是应用关系变化可能导致 OopMap 中内容变化的指令非常多。实际上 HotSpot 只是在 特定的位置
（安全点）记录这些信息。即程序执行时并非在所有地方都能停顿下开始 GC，只有在到达安全点才能暂停。

Safepoint 不能太少以至于让 GC 等待很长时间，也不能过于频繁以致于过分增加运行时负荷。在指令序列复用，比如方法调用，循环跳转，异常跳转等具有这些功能时才会产生 Safepoint。

如何在 GC 发生时如何让所有的线程都跑在最近的安全点再停顿下来？

+ 抢先式中断 Preemptive Suspension

抢先式中断不需要线程的执行代码主动去配合，在 GC 发生时，首先会把所有线程全部中断，如果发现有线程中断的地方不在安全点，就恢复线程，让他跑到安全点。

> 现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应 GC 事件。

+ 主动式中断 Voluntary Suspension

当 GC 需要中断线程时，不直接对线程操作，仅仅简单的设置一个标志，各个线程执行时会主动去轮询这个标志，发现中断标志为真时就自己挂起。轮询标志的地方与安全点
重合，在加上创建对象需要分配内存的地方。

## 安全区域 Safe Region

线程处于 Sleep 状态或者 Blocked 状态，这时候线程无法响应 JVM 的中断请求，走到安全的地方中断挂起，JVM 也不可能等待线程重新分配 CPU 时间。
这时需要安全区域 Safe Region 来解决。 

安全区域是指一段代码片段之中，引用关系不会发生变化。在这个区域中的任何地方开始 GC 都是安全的。Safe Region 可以看作为被扩展的 Safepoint。

在线程执行到 Safe Region 中的代码时，首先标识自己已经进入 Safe Region ,当这段时间 JVM 要发起 GC 时，就不用管标识自己为 Safe Region 状态的线程了。
在线程要离开 Safe Region 时，它要检查系统是否已经完成了整个 GC 过程，如果完成了，那线程继续执行，否则他必须等待直到收到可以安全离开 Safe Region 的信号为止。