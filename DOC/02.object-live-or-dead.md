# 对象已死吗

## 引用计数器算法

思路：给对象加一个引用计数器，当一个地方引用它时，计数器 +1，引用失效时，计数器 -1，计数器为0的对象时不再被使用的。

主流的 Java 虚拟机不使用此算法来管理内存，因为它很难解决对象的循环引用问题。

## 可达性分析算法

主流的商用程序语言的主流实现中，使用可达性分析来判断对象是否存活。

思路：通过一系列称为 “GC Roots” 的对象作为起始点，从这个节点开始向下搜索，搜索所走过的路径称为 引用链， 当一个对象
到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。

Java 语言中，可作为 GC Roots 的对象包括：
+ 虚拟机栈（栈帧中的本地变量表）中引用的对象
+ 方法去中静态属性引用的对象
+ 方法区中常量引用的对象
+ 本地方法栈中 JNI 引用的对象

## Java引用

**引用**

如果 reference 类型的数据中存储的数值代表的是另一块内存中的起始地址称为这块内存代表着一个引用。

**Java 扩展引用**

+ 强引用： 程序代码中普遍存在类似 `Object obj = new Object()` 的这类引用，只要强引用在，垃圾回收器永远不会回收被引用的对象。
+ 软引用： 用于描述一些还有用但是并非必须的对象。对于软引用关联着的对象，在系统将发生内存溢出异常之前，会把这些对象列进回收范围
    中进行第二次回收，如果回收后还是没有足够的内存，才会抛出内存溢出异常。JDK 1.2之后 SoftReference 类来实现软引用。
+ 弱引用： 用来描述非必需对象的，但是比软引用关联更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，
    无论当前内存是否足够，都会回收被弱应用关联的对象。JDK 1.2 之后 WeakReference 类来实现弱引用。
+ 虚引用： 最弱的一种引用关系。一个对象是否有虚引用的存在，不会对其生存时间构成影响，也无法通过虚应用来获得一个对象的实例。唯一
    目的是能在这个对象被收集器回收时收到一个系统通知。 JDK 1.2 之后，PlantomReference 类来实现虚引用。

## 生存还是死亡

1. 在可达性分析算法中不可达的对象，处于缓刑的过程，要宣告一个对象死亡,至少需要经历2次标记过过程:如果对象进行可达性分析后发现没有与
GC Roots 相链接的引用链，它将会被第一次标记并进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。如果对象没有覆盖 finalize()
方法或者 finalize() 方法已经被调用，虚拟机将这两种情况视为没必要执行。

2. 如果这个对象被判定为有必要执行 finalize() 方法，那么会被放在一个 F-Queue 的队列中，并在稍后有一个虚拟机自动建立的、低优先级的 Finalizer 
线程去执行它。

3. finalize() 方法是对象逃脱死亡的最后一次方法，稍后 GC 会对 F-Queue 中的对象进行小规模的标记，如果对象在 finalize() 中成功拯救自己——只要重新
与引用链上的任一个对象建立连即可，比如把this 赋值给某个类的变量或者对象的成员变量，那么第二次标记时，将会被移除 即将回收 的集合。如果还没有逃脱，
基本上就真的被回收了。

> 建议忽略 Java 中 finalize() 方法的存在，使用 try-finally 或其他方式替代。

## 回收方法区

Java 虚拟机规范中不要求虚拟机在方法去实现垃圾收集，而且在方法去中进行来及回收的性价比较低。 HotSpot中没有垃圾回收。

永久代中的垃圾回收主要有2部分：废弃常量和无用的类。

无用的类 的判断条件：

1. 该类的所有实例都已被回收，也就是说 Java 堆中不存在该类的任何实例。
2. 加载该类的 ClassLoader 已经被回收。
3. 该类对于的 Java.lang.Class 对象如果在任何地方被引用，无法在任何地方通过反射访问该类的方法。