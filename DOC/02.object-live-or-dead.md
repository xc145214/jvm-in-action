# 对象已死吗

## 引用计数器算法

思路：给对象加一个引用计数器，当一个地方引用它时，计数器 +1，引用失效时，计数器 -1，计数器为0的对象时不再被使用的。

主流的 Java 虚拟机不使用此算法来管理内存，因为它很难解决对象的循环引用问题。

## 可达性分析算法

主流的商用程序语言的主流实现中，使用可达性分析来判断对象是否存活。

思路：通过一系列称为 “GC Roots” 的对象作为起始点，从这个节点开始向下搜索，搜索所走过的路径称为 引用链， 当一个对象
到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。

Java 语言中，可作为 GC Roots 的对象包括：
+ 虚拟机栈（栈帧中的本地变量表）中引用的对象
+ 方法去中静态属性引用的对象
+ 方法区中常量引用的对象
+ 本地方法栈中 JNI 引用的对象

## Java引用

**引用**

如果 reference 类型的数据中存储的数值代表的是另一块内存中的起始地址称为这块内存代表着一个引用。

**Java 扩展引用**

+ 强引用： 程序代码中普遍存在类似 `Object obj = new Object()` 的这类引用，只要强引用在，垃圾回收器永远不会回收被引用的对象。
+ 软引用： 用于描述一些还有用但是并非必须的对象。对于软引用关联着的对象，在系统将发生内存溢出异常之前，会把这些对象列进回收范围
    中进行第二次回收，如果回收后还是没有足够的内存，才会抛出内存溢出异常。JDK 1.2之后 SoftReference 类来实现软引用。
+ 弱引用： 用来描述非必需对象的，但是比软引用关联更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，
    无论当前内存是否足够，都会回收被弱应用关联的对象。JDK 1.2 之后 WeakReference 类来实现弱引用。
+ 虚引用： 最弱的一种引用关系。一个对象是否有虚引用的存在，不会对其生存时间构成影响，也无法通过虚应用来获得一个对象的实例。唯一
    目的是能在这个对象被收集器回收时收到一个系统通知。 JDK 1.2 之后，PlantomReference 类来实现虚引用。

## 